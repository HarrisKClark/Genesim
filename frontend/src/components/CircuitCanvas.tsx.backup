import { useRef, useState, useCallback, useEffect, useMemo } from 'react'
import { useDrop } from 'react-dnd'
import CircuitNode from './CircuitNode'
import './CircuitCanvas.css'
import { CircuitComponent } from '../types/dnaTypes'
import { COMPONENT_COLORS, COMPONENT_SIZES, DNA_LENGTH, BP_PER_PIXEL_BASE, generateDNA } from '../constants/circuitConstants'
import { bpToX as bpToXUtil, xToBp as xToBpUtil, getBpFromMouse as getBpFromMouseUtil, getCursorPositionFromMouse as getCursorPositionFromMouseUtil } from '../utils/coordinateUtils'
import { useUndoRedo } from '../hooks/useUndoRedo'
import { useCustomScrollbar } from '../hooks/useCustomScrollbar'
import { useDNASelection } from '../hooks/useDNASelection'
import { useDNAEditing } from '../hooks/useDNAEditing'
import DNASequenceRenderer from './DNA/DNASequenceRenderer'
import DNACursor from './DNA/DNACursor'
import DNASelectionHighlight from './DNA/DNASelectionHighlight'
import SelectionInfo from './SelectionInfo'
import CustomScrollbar from './CustomScrollbar'
import ContextMenu from './ContextMenu'
import DragPreview from './DragPreview'

interface CircuitCanvasProps {
  onCircuitChange: (data: CircuitComponent[]) => void
  circuitData: CircuitComponent[] | null
  zoomSensitivity: number
  fileName?: string
}

export default function CircuitCanvas({ onCircuitChange, circuitData, fileName = 'Untitled Circuit' }: CircuitCanvasProps) {
  const canvasRef = useRef<HTMLDivElement>(null)
  const scrollContainerRef = useRef<HTMLDivElement>(null)
  const hasInitialCenteredRef = useRef(false)
  const prevZoomRef = useRef<number | null>(null)
  const [components, setComponents] = useState<CircuitComponent[]>(() => {
    const initial = circuitData || []
    return initial.map(comp => ({
      ...comp,
      length: comp.length || COMPONENT_SIZES[comp.type] || 100,
    }))
  })
  
  // Sync circuitData prop changes
  useEffect(() => {
    if (circuitData) {
      setComponents(circuitData.map(comp => ({
        ...comp,
        length: comp.length || COMPONENT_SIZES[comp.type] || 100,
      })))
    }
  }, [circuitData])

  const [selectedId, setSelectedId] = useState<string | null>(null)
  const [dnaSequence, setDnaSequence] = useState<string[]>(generateDNA(DNA_LENGTH))
  const [dnaLength, setDnaLength] = useState(DNA_LENGTH)
  const [canvasWidth, setCanvasWidth] = useState(0)
  const [canvasHeight, setCanvasHeight] = useState(0)
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number; bp: number } | null>(null)
  
  // Drag preview state for component insertion
  const [dragPreviewPosition, setDragPreviewPosition] = useState<{
    bp: number
    componentLength: number
    componentType: string
    componentName: string
    blockedPartIds?: string[]
    snappedFromBlocked?: boolean
  } | null>(null)

  // Drag state for moving an already-placed part box
  const [draggingPlacedPart, setDraggingPlacedPart] = useState<{
    id: string
    length: number
  } | null>(null)
  const draggingPlacedPartStartRef = useRef<number | null>(null)
  // When user clicks somewhere inside the box, preserve that grab offset so it doesn't "jump" to re-center.
  // Value is in bp units: mouseBpFloat - boxCenterBp at drag start.
  const draggingPlacedPartMouseOffsetBpRef = useRef<number>(0)
  
  // Component drag state for abstract blocks
  const [draggingComponentId, setDraggingComponentId] = useState<string | null>(null)
  const dragComponentStartRef = useRef({ x: 0, startBp: 0 })
  const hasDraggedRef = useRef(false)

  // Selection drag ref (shared between hooks)
  const selectionDragRef = useRef<{
    startCursorPos: number | null
    isDragging: boolean
    hasMoved: boolean
  }>({
    startCursorPos: null,
    isDragging: false,
    hasMoved: false,
  })

  // Zoom state (needed early for calculations)
  const [zoom, setZoom] = useState(1)
  const [isDragging, setIsDragging] = useState(false)
  const [dragStart, setDragStart] = useState({ x: 0, scrollLeft: 0 })

  // Calculate base pair rendering dimensions
  const fontSize = useMemo(() => Math.max(12, Math.min(18, 12 + (zoom - 1) * 0.8)), [zoom])
  const baseWidth = useMemo(() => Math.max(fontSize + 4, Math.min(20, 2 * zoom)), [fontSize, zoom])
  const minSpacing = useMemo(() => baseWidth + 2, [baseWidth])
  const baseHeight = useMemo(() => Math.max(12, Math.min(24, 12 * zoom)), [zoom])
  const strandSpacing = useMemo(() => Math.max(20, Math.min(40, 20 * zoom)), [zoom])
  
  // Calculate base bpPerPixel
  const baseBpPerPixel = BP_PER_PIXEL_BASE / zoom
  
  // Calculate effective bpPerPixel
  const bpPerPixel = useMemo(() => {
    const transitionStart = 1.5
    const transitionEnd = 2.5
    let transitionFactor = 0
    if (zoom >= transitionStart && zoom <= transitionEnd) {
      transitionFactor = (zoom - transitionStart) / (transitionEnd - transitionStart)
    } else if (zoom > transitionEnd) {
      transitionFactor = 1
    }
    
    const minBpPerPixel = 1 / minSpacing
    return baseBpPerPixel * (1 - transitionFactor) + Math.min(baseBpPerPixel, minBpPerPixel) * transitionFactor
  }, [zoom, baseBpPerPixel, minSpacing])
  
  const totalWidth = useMemo(() => dnaLength / bpPerPixel, [dnaLength, bpPerPixel])

  const placedIntervals = useMemo(() => {
    return components
      .filter((c) => c.startBp !== undefined)
      .map((c) => {
        const start = c.startBp ?? 0
        const len = c.length || COMPONENT_SIZES[c.type] || 100
        const end = c.endBp ?? (start + len)
        return { id: c.id, start, end }
      })
  }, [components])

  const resolveNoOverlapStartBp = useCallback(
    (desiredStartBp: number, opts: { maxStartBp: number; excludeId?: string; componentLength?: number }) => {
      const minStartBp = 0
      const maxStartBp = Math.max(0, opts.maxStartBp)
      const clamped = Math.max(minStartBp, Math.min(maxStartBp, desiredStartBp))
      // Get component length from opts, or estimate from maxStartBp (dnaLength - compLength = maxStartBp)
      const compLength = opts.componentLength || (dnaLength - maxStartBp)

      // Check if placing a component at `bp` with length `compLength` would overlap any existing interval
      const wouldOverlap = (bp: number) => {
        const candidateStart = bp
        const candidateEnd = bp + compLength
        return placedIntervals.some((it) => {
          if (it.id === opts.excludeId) return false
          // Two intervals [a, b) and [c, d) overlap if a < d && c < b
          return candidateStart < it.end && it.start < candidateEnd
        })
      }

      // Get all intervals that the candidate would overlap with
      const getBlockers = (bp: number) => {
        const candidateStart = bp
        const candidateEnd = bp + compLength
        return placedIntervals.filter((it) => {
          if (it.id === opts.excludeId) return false
          return candidateStart < it.end && it.start < candidateEnd
        })
      }

      const blockers = getBlockers(clamped)
      if (blockers.length === 0) {
        return { startBp: clamped, blockedPartIds: [] as string[], snappedFromBlocked: false }
      }

      // Find candidate positions: just before each blocker's start, or just after each blocker's end
      const candidates = blockers
        .flatMap((b) => [
          b.start - compLength, // Place component ending just before blocker starts
          b.end,                // Place component starting just after blocker ends
        ])
        .map((bp) => Math.max(minStartBp, Math.min(maxStartBp, bp)))
        .filter((bp) => !wouldOverlap(bp))

      if (candidates.length === 0) {
        // Fallback: scan outward (rare; assumes intervals are mostly disjoint).
        let left = clamped
        let right = clamped
        while (left > minStartBp || right < maxStartBp) {
          if (left > minStartBp) {
            left -= 1
            if (!wouldOverlap(left)) return { startBp: left, blockedPartIds: blockers.map((b) => b.id), snappedFromBlocked: true }
          }
          if (right < maxStartBp) {
            right += 1
            if (!wouldOverlap(right)) return { startBp: right, blockedPartIds: blockers.map((b) => b.id), snappedFromBlocked: true }
          }
        }
        return { startBp: clamped, blockedPartIds: blockers.map((b) => b.id), snappedFromBlocked: true }
      }

      let best = candidates[0]
      let bestDist = Math.abs(best - clamped)
      for (const c of candidates.slice(1)) {
        const d = Math.abs(c - clamped)
        if (d < bestDist) {
          best = c
          bestDist = d
        }
      }
      return { startBp: best, blockedPartIds: blockers.map((b) => b.id), snappedFromBlocked: true }
    },
    [placedIntervals, dnaLength]
  )
  
  // Hard cutoff between abstract and DNA view (no overlap)
  const viewCutoffZoom = 2.0
  const transitionFactor = useMemo(() => {
    return zoom >= viewCutoffZoom ? 1 : 0
  }, [zoom])
  
  const showBasePairs = zoom >= viewCutoffZoom
  const showAbstractView = zoom < viewCutoffZoom
  
  // Calculate centered positions
  const lineY = useMemo(() => canvasHeight > 0 ? canvasHeight / 2 : 200, [canvasHeight])
  const lineX = useMemo(() => canvasWidth > 0 && totalWidth < canvasWidth ? (canvasWidth - totalWidth) / 2 : 0, [canvasWidth, totalWidth])

  // Coordinate conversion functions using utilities
  const bpToX = useCallback((bp: number) => bpToXUtil(bp, bpPerPixel), [bpPerPixel])
  const xToBp = useCallback((x: number) => xToBpUtil(x, bpPerPixel), [bpPerPixel])
  const getBpFromMouse = useCallback((e: React.MouseEvent | MouseEvent): number | null => {
    return getBpFromMouseUtil(e, canvasRef, scrollContainerRef, canvasWidth, totalWidth, bpPerPixel, dnaLength)
  }, [canvasWidth, totalWidth, bpPerPixel, dnaLength])
  const getCursorPositionFromMouse = useCallback((e: React.MouseEvent | MouseEvent): number | null => {
    return getCursorPositionFromMouseUtil(e, canvasRef, scrollContainerRef, canvasWidth, totalWidth, bpPerPixel, dnaLength, showBasePairs)
  }, [canvasWidth, totalWidth, bpPerPixel, dnaLength, showBasePairs])

  // Calculate canvas width and height
  useEffect(() => {
    const updateDimensions = () => {
      if (canvasRef.current) {
        const rect = canvasRef.current.getBoundingClientRect()
        setCanvasWidth(rect.width)
        setCanvasHeight(rect.height)
      }
    }
    updateDimensions()
    window.addEventListener('resize', updateDimensions)
    return () => window.removeEventListener('resize', updateDimensions)
  }, [])

  // Zoom and Pan handlers
  const handleWheel = useCallback((e: React.WheelEvent) => {
    e.preventDefault()
    e.stopPropagation()
    const zoomFactor = 1.1
    const zoomDirection = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor
    setZoom((prevZoom) => {
      const newZoom = Math.max(0.5, Math.min(10, prevZoom * zoomDirection))
      return newZoom
    })
  }, [])

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.button !== 0) return
    if (!showBasePairs) return
    if (selectionDragRef.current.isDragging) return
    
    const target = e.target as HTMLElement
    // If user is interacting with a placed part, don't pan the canvas.
    if (target.closest('.dna-part-box') || target.closest('.dna-part-delete')) {
      return
    }
    if (target.closest('.circuit-node') || target.closest('.canvas-controls') || target.closest('.abstract-component-block')) {
      return
    }
    
    if (target.hasAttribute('data-bp-index') || target.closest('[data-bp-index]')) {
      return
    }
    
    e.preventDefault()
    setIsDragging(true)
    if (scrollContainerRef.current) {
      setDragStart({
        x: e.clientX,
        scrollLeft: scrollContainerRef.current.scrollLeft,
      })
    }
  }, [showBasePairs])

  useEffect(() => {
    if (!isDragging || !showBasePairs) return

    const handleMouseMove = (e: MouseEvent) => {
      if (!scrollContainerRef.current) return
      const deltaX = e.clientX - dragStart.x
      scrollContainerRef.current.scrollLeft = dragStart.scrollLeft - deltaX
    }

    const handleMouseUp = () => {
      setIsDragging(false)
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)

    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isDragging, dragStart, showBasePairs])

  // Handle zoom via scroll container wheel events
  useEffect(() => {
    if (!scrollContainerRef.current) return
    
    const container = scrollContainerRef.current
    
    const handleWheel = (e: WheelEvent) => {
      e.preventDefault()
      e.stopPropagation()
      
      const zoomFactor = 1.1
      const zoomDirection = e.deltaY > 0 ? 1 / zoomFactor : zoomFactor
      setZoom((prevZoom) => {
        const newZoom = Math.max(0.5, Math.min(10, prevZoom * zoomDirection))
        return newZoom
      })
    }
    
    container.addEventListener('wheel', handleWheel, { passive: false })
    return () => {
      container.removeEventListener('wheel', handleWheel)
    }
  }, [])

  // Selection hook
  const {
    selection,
    setSelection,
    cursorBp,
    setCursorBp,
    cursorPosition,
    setCursorPosition,
    cursorVisible,
    setCursorVisible,
    cursorPlaced,
    setCursorPlaced,
    handleBaseMouseDown,
  } = useDNASelection({
    canvasRef,
    scrollContainerRef,
    canvasWidth,
    totalWidth,
    bpPerPixel,
    dnaLength,
    showBasePairs,
    draggingComponentId,
    bpToX,
    selectionDragRef,
  })

  // Undo/Redo hook
  const { saveState, handleUndo, handleRedo } = useUndoRedo({
    dnaSequence,
    dnaLength,
    components,
    onCircuitChange,
    setDnaSequence,
    setDnaLength,
    setComponents,
    setSelection,
  })

  // Editing hook
  const {
    clipboard,
    handleDeleteSelection,
    handleCopySelection,
    handleCutSelection,
    handlePaste,
    handleReverseComplement,
  } = useDNAEditing({
    dnaSequence,
    dnaLength,
    components,
    selection,
    cursorPosition,
    setDnaSequence,
    setDnaLength,
    setComponents,
    setSelection,
    setCursorPosition,
    setCursorPlaced,
    setCursorVisible,
    onCircuitChange,
    saveState,
  })

  // Check if a bp position is inside any placed component
  const isInsideComponent = useCallback((bp: number) => {
    return components.some((comp) => {
      if (comp.startBp === undefined) return false
      const start = comp.startBp
      const end = comp.endBp ?? (start + (comp.length || 10))
      return bp >= start && bp < end
    })
  }, [components])

  // Set origin: rotate DNA sequence so the given bp becomes position 0
  // Components wrap around to maintain their relative positions
  const handleSetOrigin = useCallback((newOriginBp: number) => {
    if (newOriginBp <= 0 || newOriginBp >= dnaLength) return
    
    // Check if origin is inside a component - this would break the component
    if (isInsideComponent(newOriginBp)) {
      alert('Cannot set origin inside a placed component. Please choose a position outside of components.')
      return
    }
    
    saveState()
    
    // Rotate the DNA sequence
    const rotatedSequence = [
      ...dnaSequence.slice(newOriginBp),
      ...dnaSequence.slice(0, newOriginBp),
    ]
    
    // Update components - shift their positions and wrap around if needed
    const updatedComponents = components.map((comp) => {
      if (comp.startBp === undefined) return comp
      
      const oldStart = comp.startBp
      const oldEnd = comp.endBp ?? (oldStart + (comp.length || 10))
      const compLength = oldEnd - oldStart
      
      // Calculate new start position with wrapping
      let newStart = oldStart - newOriginBp
      if (newStart < 0) {
        newStart = dnaLength + newStart // Wrap around to end
      }
      
      return {
        ...comp,
        startBp: newStart,
        endBp: newStart + compLength,
      }
    })
    
    setDnaSequence(rotatedSequence)
    setComponents(updatedComponents)
    onCircuitChange(updatedComponents)
    
    // Clear any selection or cursor
    setSelection(null)
    setCursorPosition(null)
    setCursorPlaced(false)
  }, [dnaSequence, dnaLength, components, isInsideComponent, saveState, setDnaSequence, setComponents, onCircuitChange, setSelection, setCursorPosition, setCursorPlaced])

  // Delete a placed part: remove its bp segment and shift downstream components
  const handleDeletePlacedPart = useCallback((id: string) => {
    const comp = components.find((c) => c.id === id)
    if (!comp || comp.startBp === undefined) return

    const start = comp.startBp
    const end = comp.endBp ?? (start + (comp.length || 10))
    const len = Math.max(1, end - start)

    saveState()

    // Remove sequence chunk
    setDnaSequence((prev) => {
      const next = [...prev]
      next.splice(start, len)
      setDnaLength(next.length)
      return next
    })

    // Remove component and shift others
    setComponents((prev) => {
      const without = prev.filter((c) => c.id !== id)
      const updated = without.map((c) => {
        if (c.startBp !== undefined && c.startBp >= start + len) {
          const newStart = c.startBp - len
          const newEnd = (c.endBp ?? (c.startBp + (c.length || 100))) - len
          return { ...c, startBp: newStart, endBp: newEnd, x: bpToX(newStart) }
        }
        return c
      })
      onCircuitChange(updated)
      return updated
    })

    if (selectedId === id) setSelectedId(null)
  }, [components, bpToX, onCircuitChange, saveState, selectedId, setDnaSequence])

  // Drag placed part LIVE (move its bp segment while dragging so it follows the box)
  useEffect(() => {
    if (!draggingPlacedPart) return

    let raf: number | null = null
    let lastMouse: MouseEvent | null = null

    const applyMove = (e: MouseEvent) => {
      if (!canvasRef.current || !scrollContainerRef.current) return
      const rect = canvasRef.current.getBoundingClientRect()
      const scrollLeft = scrollContainerRef.current.scrollLeft
      const x = e.clientX - rect.left + scrollLeft - lineX
      const mouseBpFloat = x * bpPerPixel
      // Preserve where within the box we grabbed it (avoid jump-on-drag-start)
      const desiredCenterBp = mouseBpFloat - draggingPlacedPartMouseOffsetBpRef.current
      // IMPORTANT: targetStart is the FINAL desired start index (with the chunk still present),
      // so we should NOT subtract length when inserting after removal. Doing so causes a jump
      // specifically when dragging to the right.
      const targetStart = Math.round(desiredCenterBp - draggingPlacedPart.length / 2)
      const resolved = resolveNoOverlapStartBp(targetStart, {
        maxStartBp: dnaLength - draggingPlacedPart.length,
        excludeId: draggingPlacedPart.id,
        componentLength: draggingPlacedPart.length,
      })
      const newStart = resolved.startBp

      const currentStart = draggingPlacedPartStartRef.current
      if (currentStart === null) return
      if (newStart === currentStart) return

      // Move sequence chunk (N segment) live
      setDnaSequence((prev) => {
        const next = [...prev]
        const chunk = next.splice(currentStart, draggingPlacedPart.length)
        next.splice(newStart, 0, ...chunk)
        // length unchanged
        return next
      })

      // Update components live
      setComponents((prev) => {
        const moving = prev.find((c) => c.id === draggingPlacedPart.id)
        if (!moving || moving.startBp === undefined) return prev

        const oldStart = currentStart
        const len = draggingPlacedPart.length
        const others = prev.filter((c) => c.id !== draggingPlacedPart.id).map((c) => {
          if (c.startBp === undefined) return c
          let s = c.startBp
          let eBp = c.endBp ?? (c.startBp + (c.length || 100))

          // deletion shift
          if (s >= oldStart + len) {
            s -= len
            eBp -= len
          }
          // insertion shift
          if (s >= newStart) {
            s += len
            eBp += len
          }
          return { ...c, startBp: s, endBp: eBp, x: bpToX(s) }
        })

        const moved = { ...moving, startBp: newStart, endBp: newStart + len, x: bpToX(newStart) }
        const final = [...others, moved]
        onCircuitChange(final)
        return final
      })

      draggingPlacedPartStartRef.current = newStart
    }

    const handleMove = (e: MouseEvent) => {
      lastMouse = e
      if (raf !== null) return
      raf = window.requestAnimationFrame(() => {
        raf = null
        if (lastMouse) applyMove(lastMouse)
      })
    }

    const handleUp = () => {
      setDraggingPlacedPart(null)
      draggingPlacedPartStartRef.current = null
      draggingPlacedPartMouseOffsetBpRef.current = 0
    }

    window.addEventListener('mousemove', handleMove)
    window.addEventListener('mouseup', handleUp)
    return () => {
      if (raf !== null) window.cancelAnimationFrame(raf)
      window.removeEventListener('mousemove', handleMove)
      window.removeEventListener('mouseup', handleUp)
    }
  }, [draggingPlacedPart, bpPerPixel, dnaLength, lineX, bpToX, onCircuitChange])

  const handlePartMouseDown = useCallback((e: React.MouseEvent, comp: CircuitComponent) => {
    if (e.button !== 0) return
    if (comp.startBp === undefined) return
    e.preventDefault()
    e.stopPropagation()

    // One undo step for the whole drag
    saveState()

    // Stop any canvas drag
    setIsDragging(false)
    // Hide cursor immediately so it doesn't flash during box manipulation
    setCursorVisible(false)
    setCursorPosition(null)
    setCursorBp(null)
    setCursorPlaced(false)

    const start = comp.startBp
    const end = comp.endBp ?? (start + (comp.length || 10))
    const len = Math.max(1, end - start)
    setDraggingPlacedPart({ id: comp.id, length: len })
    draggingPlacedPartStartRef.current = start

    // Compute grab offset in bp so the box doesn't shift when drag starts
    if (canvasRef.current && scrollContainerRef.current) {
      const rect = canvasRef.current.getBoundingClientRect()
      const scrollLeft = scrollContainerRef.current.scrollLeft
      const x = e.clientX - rect.left + scrollLeft - lineX
      const mouseBpFloat = x * bpPerPixel
      const boxCenterBp = start + len / 2
      draggingPlacedPartMouseOffsetBpRef.current = mouseBpFloat - boxCenterBp
    } else {
      draggingPlacedPartMouseOffsetBpRef.current = 0
    }
  }, [saveState, setCursorVisible, setCursorPosition, setCursorBp, setCursorPlaced, lineX, bpPerPixel])


  // Center the view on initial mount or zoom/resize (but NOT when DNA length changes)
  useEffect(() => {
    if (canvasWidth > 0 && canvasHeight > 0 && totalWidth > 0 && scrollContainerRef.current) {
      // Center on initial mount or when zoom/canvas size changes
      // Don't center when DNA length changes (totalWidth changes) - preserve scroll position
      const shouldCenter = !hasInitialCenteredRef.current || 
                          (prevZoomRef.current !== null && prevZoomRef.current !== zoom)
      
      if (shouldCenter) {
        const newScrollLeft = totalWidth > canvasWidth ? (totalWidth - canvasWidth) / 2 : 0
        scrollContainerRef.current.scrollLeft = Math.max(0, newScrollLeft)
        setScrollLeft(Math.max(0, newScrollLeft))
        hasInitialCenteredRef.current = true
        prevZoomRef.current = zoom
      }
    }
  }, [canvasWidth, canvasHeight, zoom]) // Removed totalWidth from dependencies - preserve scroll when DNA length changes

  // Sync scroll position with state
  const [scrollLeft, setScrollLeft] = useState(0)
  useEffect(() => {
    if (!scrollContainerRef.current) return
    
    const container = scrollContainerRef.current
    const handleScroll = () => {
      setScrollLeft(container.scrollLeft)
    }
    
    container.addEventListener('scroll', handleScroll)
    return () => {
      container.removeEventListener('scroll', handleScroll)
    }
  }, [])

  // Calculate content dimensions
  const contentHeight = Math.max(400, canvasHeight || 400)
  const minInnerWidth = useMemo(() => {
    if (canvasWidth > 0) {
      return Math.max(canvasWidth + 1, totalWidth)
    }
    return Math.max(1, totalWidth)
  }, [canvasWidth, totalWidth])
  
  const minInnerHeight = useMemo(() => {
    if (canvasHeight > 0) {
      return canvasHeight
    }
    return contentHeight
  }, [canvasHeight, contentHeight])

  // Custom scrollbar hook
  const scrollbar = useCustomScrollbar({
    scrollContainerRef,
    canvasWidth,
    minInnerWidth,
    scrollLeft,
    setScrollLeft,
  })

  // Handle component drag in abstract view
  useEffect(() => {
    if (!draggingComponentId || showBasePairs) return

    let rafId: number | null = null
    let lastMouseEvent: MouseEvent | null = null

    const handleMouseMove = (e: MouseEvent) => {
      if (!canvasRef.current || !scrollContainerRef.current) return
      
      lastMouseEvent = e
      
      const deltaX = Math.abs(e.clientX - dragComponentStartRef.current.x)
      if (deltaX > 3) {
        hasDraggedRef.current = true
      }
      
      if (rafId !== null) return
      
      rafId = requestAnimationFrame(() => {
        rafId = null
        
        if (!lastMouseEvent || !canvasRef.current || !scrollContainerRef.current) return
        
        const rect = canvasRef.current.getBoundingClientRect()
        const scrollLeft = scrollContainerRef.current.scrollLeft
        const x = (lastMouseEvent.clientX - rect.left) + scrollLeft - lineX
        // Use EXACT same logic as DNA view: calculate bp from pixel position, then center component
        const mouseBpFloat = x * bpPerPixel
        
        setComponents((prev) => {
          const draggingComp = prev.find(c => c.id === draggingComponentId)
          if (!draggingComp) return prev
          
          const compLength = draggingComp.length || 100
          // Center the component on the mouse (same as DNA view hover logic)
          const targetStart = Math.round(mouseBpFloat - compLength / 2)
          
          // Apply no-overlap logic (same as DNA view drag logic)
          const resolved = resolveNoOverlapStartBp(targetStart, {
            maxStartBp: dnaLength - compLength,
            excludeId: draggingComp.id, // Exclude the component being dragged
            componentLength: compLength,
          })
          const resolvedBp = resolved.startBp
          
          return prev.map((comp) => {
            if (comp.id === draggingComponentId) {
              return {
                ...comp,
                startBp: resolvedBp,
                endBp: resolvedBp + compLength,
                x: bpToX(resolvedBp),
              }
            }
            return comp
          })
        })
      })
    }

    const handleMouseUp = () => {
      if (rafId !== null) {
        cancelAnimationFrame(rafId)
        rafId = null
      }
      
      if (draggingComponentId) {
        setComponents((prev) => {
          const updated = prev.map((comp) => {
            if (comp.id === draggingComponentId) {
              return comp
            }
            return comp
          })
          onCircuitChange(updated)
          return updated
        })
      }
      setTimeout(() => {
        hasDraggedRef.current = false
      }, 0)
      setDraggingComponentId(null)
      lastMouseEvent = null
    }

    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)

    return () => {
      if (rafId !== null) {
        cancelAnimationFrame(rafId)
      }
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
    }
  }, [draggingComponentId, showBasePairs, lineX, dnaLength, bpPerPixel, bpToX, onCircuitChange, resolveNoOverlapStartBp])

  // Insert component into DNA sequence
  const insertComponentIntoDNA = useCallback((
    component: CircuitComponent,
    position: number,
    componentLength: number
  ) => {
    saveState()
    
    const placeholderSeq = Array(componentLength).fill('N')
    
    setDnaSequence((prev) => {
      const newSeq = [...prev]
      newSeq.splice(position, 0, ...placeholderSeq)
      setDnaLength(newSeq.length)
      return newSeq
    })
    
    setComponents((prev) => {
      const updated = prev.map((comp) => {
        if (comp.startBp !== undefined && comp.startBp >= position) {
          return {
            ...comp,
            startBp: comp.startBp + componentLength,
            endBp: (comp.endBp || 0) + componentLength,
            x: bpToX(comp.startBp + componentLength),
          }
        }
        return comp
      })
      
      const newComponent: CircuitComponent = {
        ...component,
        startBp: position,
        endBp: position + componentLength,
        x: bpToX(position),
      }
      
      const final = [...updated, newComponent]
      onCircuitChange(final)
      return final
    })
  }, [bpToX, onCircuitChange, saveState])
  
  const [{ isOver }, drop] = useDrop(() => ({
    accept: 'circuit-component',
    hover: (item: { type: string; name: string; subType?: string }, monitor) => {
      const offset = monitor.getClientOffset()
      if (offset && canvasRef.current && scrollContainerRef.current) {
        const rect = canvasRef.current.getBoundingClientRect()
        const scrollLeft = scrollContainerRef.current.scrollLeft
        const x = offset.x - rect.left + scrollLeft - lineX
        
        // Check if mouse is over DNA area (within totalWidth)
        if (x >= 0 && x <= totalWidth) {
          const componentLength = COMPONENT_SIZES[item.type] || 100
          // Root cause fix:
          // - Mouse-following preview is CENTERED on the mouse (translate(-50%))
          // - DNA gap/box uses startBp (left edge)
          // So we compute startBp such that the CENTER of the gap aligns with the mouse.
          const mouseBpFloat = x * bpPerPixel
          const startBp = Math.round(mouseBpFloat - componentLength / 2)
          const resolved = resolveNoOverlapStartBp(startBp, { maxStartBp: dnaLength, componentLength })
          const bpPos = resolved.startBp
          
          setDragPreviewPosition({
            bp: bpPos,
            componentLength,
            componentType: item.type,
            componentName: item.name,
            blockedPartIds: resolved.blockedPartIds,
            snappedFromBlocked: resolved.snappedFromBlocked,
          })
        } else {
          // Outside DNA area
          setDragPreviewPosition(null)
        }
      }
    },
    drop: (item: { type: string; name: string; subType?: string }, monitor) => {
      // Clear any selection to prevent browser default behavior
      setSelection(null)
      
      const componentLength = COMPONENT_SIZES[item.type] || 100
      
      // Use dragPreviewPosition if available (DNA view), otherwise calculate from mouse (abstract view)
      let bpPos: number
      if (dragPreviewPosition) {
        // DNA view: use resolved position from hover
        bpPos = dragPreviewPosition.bp
      } else {
        // Abstract view: calculate from mouse position and apply no-overlap logic
        const offset = monitor.getClientOffset()
        if (!offset || !canvasRef.current || !scrollContainerRef.current) {
          setDragPreviewPosition(null)
          return
        }
        const rect = canvasRef.current.getBoundingClientRect()
        const scrollLeft = scrollContainerRef.current.scrollLeft
        const x = offset.x - rect.left + scrollLeft - lineX
        const mouseBpFloat = x * bpPerPixel
        const startBp = Math.round(mouseBpFloat - componentLength / 2)
        // Apply no-overlap logic for abstract view too
        const resolved = resolveNoOverlapStartBp(startBp, { maxStartBp: dnaLength, componentLength })
        bpPos = resolved.startBp
      }
      
      const y = showAbstractView ? 190 : 200
      
      const newComponent: CircuitComponent = {
        id: `${item.type}-${Date.now()}`,
        type: item.type,
        name: item.name,
        subType: item.subType,
        x: bpToX(bpPos),
        y,
        startBp: bpPos,
        endBp: bpPos + componentLength,
        length: componentLength,
        color: COMPONENT_COLORS[item.type] || '#666',
      }
      
      insertComponentIntoDNA(newComponent, bpPos, componentLength)
      setDragPreviewPosition(null)
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
    }),
  }), [bpToX, bpPerPixel, showAbstractView, lineX, dnaLength, insertComponentIntoDNA, dragPreviewPosition, showBasePairs, totalWidth, resolveNoOverlapStartBp])

  const handleNodeMove = useCallback((id: string, x: number, y: number) => {
    setComponents((prev) => {
      const updated = prev.map((comp) => {
        if (comp.id === id) {
          const bpPos = Math.max(0, Math.min(dnaLength - 1, xToBp(x)))
          const compLength = comp.length || 100
          return {
            ...comp,
            x: bpToX(bpPos),
            y,
            startBp: bpPos,
            endBp: bpPos + compLength,
          }
        }
        return comp
      })
      onCircuitChange(updated)
      return updated
    })
  }, [onCircuitChange, bpToX, xToBp, dnaLength])

  const handleNodeDelete = useCallback((id: string) => {
    saveState()
    
    setComponents((prev) => {
      const updated = prev.filter((comp) => comp.id !== id)
      onCircuitChange(updated)
      return updated
    })
    if (selectedId === id) {
      setSelectedId(null)
    }
  }, [selectedId, onCircuitChange, saveState])

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return
      }
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selection) {
        e.preventDefault()
        handleCopySelection()
      }
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'x' && selection) {
        e.preventDefault()
        handleCutSelection()
      }
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'v' && clipboard) {
        e.preventDefault()
        handlePaste()
      }
      
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selection) {
          e.preventDefault()
          handleDeleteSelection()
        } else if (selectedId) {
          e.preventDefault()
          handleNodeDelete(selectedId)
        }
      }
      
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault()
        handleUndo()
      }
      
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault()
        handleRedo()
      }
      
      if (e.key === 'Escape') {
        setSelection(null)
        setContextMenu(null)
        setSelectedId(null)
      }
    }
    
    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [selection, clipboard, selectedId, handleCopySelection, handleCutSelection, handlePaste, handleDeleteSelection, handleNodeDelete, handleUndo, handleRedo, setSelection])

  // Handlers for DNASequenceRenderer
  const handleCursorMove = useCallback((e: React.MouseEvent) => {
    // Don't activate cursor while manipulating a placed part box
    if (draggingPlacedPart) return
    if ((e.target as HTMLElement).closest?.('.dna-part-box') || (e.target as HTMLElement).closest?.('.dna-part-delete')) {
      return
    }
    if (!cursorPlaced && !selectionDragRef.current.isDragging) {
      const cursorPos = getCursorPositionFromMouse(e)
      if (cursorPos !== null) {
        setCursorPosition(cursorPos)
        setCursorVisible(true)
      }
    }
  }, [draggingPlacedPart, cursorPlaced, getCursorPositionFromMouse, setCursorPosition, setCursorVisible])

  const handleCursorLeave = useCallback(() => {
    if (!cursorPlaced && !selectionDragRef.current.isDragging && !selection) {
      setCursorVisible(false)
      setCursorPosition(null)
    }
  }, [cursorPlaced, selection, setCursorVisible, setCursorPosition])

  const handleBaseEnter = useCallback((index: number) => {
    // Don't activate cursor while manipulating a placed part box
    if (draggingPlacedPart) return
    setCursorBp(index)
    if (!cursorPlaced && showBasePairs) {
      const cursorPos = index + 1
      setCursorPosition(cursorPos)
      setCursorVisible(true)
    }
  }, [draggingPlacedPart, cursorPlaced, showBasePairs, setCursorBp, setCursorPosition, setCursorVisible])

  const handleBaseLeave = useCallback(() => {
    setCursorBp(null)
  }, [setCursorBp])

  const handleComponentClick = useCallback((comp: CircuitComponent) => {
    setSelectedId(comp.id)
    setSelection(null)
  }, [setSelectedId, setSelection])

  const handleComponentMouseDown = useCallback((e: React.MouseEvent, comp: CircuitComponent) => {
    if (e.button !== 0) return
    if ((e.target as HTMLElement).closest('.abstract-block-delete')) {
      return
    }
    e.preventDefault()
    e.stopPropagation()
    
    // If component is placed on DNA (has startBp), use the same drag mechanism as DNA view
    // This ensures the DNA sequence gets spliced correctly when moving
    if (comp.startBp !== undefined) {
      // Use the same logic as handleTestPartMouseDown (DNA view drag)
      saveState()
      setIsDragging(false)
      setCursorVisible(false)
      setCursorPosition(null)
      setCursorBp(null)
      setCursorPlaced(false)

      const start = comp.startBp
      const end = comp.endBp ?? (start + (comp.length || 100))
      const len = Math.max(1, end - start)
      setDraggingPlacedPart({ id: comp.id, length: len })
      draggingPlacedPartStartRef.current = start

      // Compute grab offset in bp so the box doesn't shift when drag starts
      if (canvasRef.current && scrollContainerRef.current) {
        const rect = canvasRef.current.getBoundingClientRect()
        const scrollLeft = scrollContainerRef.current.scrollLeft
        const x = e.clientX - rect.left + scrollLeft - lineX
        const mouseBpFloat = x * bpPerPixel
        const boxCenterBp = start + len / 2
        draggingPlacedPartMouseOffsetBpRef.current = mouseBpFloat - boxCenterBp
      } else {
        draggingPlacedPartMouseOffsetBpRef.current = 0
      }
      
      setSelectedId(comp.id)
      return
    }
    
    // For unplaced components, use the simple abstract view drag
    hasDraggedRef.current = false
    const startBp = comp.startBp || 0
    dragComponentStartRef.current = { x: e.clientX, startBp: startBp }
    setDraggingComponentId(comp.id)
    setSelectedId(comp.id)
  }, [saveState, setCursorVisible, setCursorPosition, setCursorBp, setCursorPlaced, lineX, bpPerPixel])

  // Set up refs for drag and drop
  useEffect(() => {
    if (canvasRef.current) {
      drop(canvasRef.current)
    }
  }, [drop])

  // Clear drag preview position when drag ends (isOver becomes false)
  useEffect(() => {
    if (!isOver && dragPreviewPosition) {
      // Small delay to allow drop handler to run first
      const timer = setTimeout(() => {
        setDragPreviewPosition(null)
      }, 100)
      return () => clearTimeout(timer)
    }
  }, [isOver, dragPreviewPosition])

  return (
    <div
      ref={canvasRef}
      className={`circuit-canvas ${isOver ? 'drag-over' : ''} ${isDragging ? 'dragging' : ''}`}
      onWheel={handleWheel}
      onMouseDown={handleMouseDown}
      onContextMenu={(e) => {
        if (showBasePairs) {
          e.preventDefault()
          const bp = getBpFromMouse(e)
          if (bp !== null) {
            setContextMenu({ x: e.clientX, y: e.clientY, bp })
          }
        }
      }}
      onClick={(e) => {
        // Don't clear selection if we just finished a drag selection
        // The selection should persist after dragging until user explicitly clicks off
        if (selectionDragRef.current.hasMoved && selectionDragRef.current.isDragging === false) {
          // Reset the flag but keep the selection
          selectionDragRef.current.hasMoved = false
          return
        }
        
        const target = e.target as HTMLElement
        const isClickingComponent = target.closest('.abstract-component-block') || target.closest('.circuit-node')
        const isClickingDNABase = target.hasAttribute('data-bp-index') || target.closest('[data-bp-index]')
        const isClickingControl = target.closest('.canvas-controls') || target.closest('.selection-info')
        const isClickingScrollbar = target.closest('.custom-scrollbar-horizontal')
        
        // Only clear selection when clicking on empty canvas (not on DNA, components, or controls)
        if (!isClickingComponent && !isClickingDNABase && !isClickingControl && !isClickingScrollbar) {
          setContextMenu(null)
          setSelection(null)
          setSelectedId(null)
          setCursorPlaced(false)
          setCursorVisible(false)
          setCursorPosition(null)
        }
      }}
    >
      <div 
        ref={scrollContainerRef}
        className="canvas-scroll-container"
        style={{
          width: '100%',
          height: '100%',
          overflowX: 'hidden',
          overflowY: 'hidden',
          position: 'relative',
          cursor: showBasePairs && isDragging ? 'grabbing' : showBasePairs ? 'grab' : 'default',
        }}
      >
        <div 
          className="canvas-inner-wrapper"
          style={{ 
            width: `${minInnerWidth}px`, 
            height: `${minInnerHeight}px`,
            minWidth: `${minInnerWidth}px`,
            minHeight: `${minInnerHeight}px`,
            position: 'relative',
          }}
        >
          <DNASequenceRenderer
            dnaSequence={dnaSequence}
            dnaLength={dnaLength}
            components={components}
            selection={selection}
            cursorBp={cursorBp}
            cursorPlaced={cursorPlaced}
            selectedId={selectedId}
            draggingComponentId={draggingComponentId}
            showBasePairs={showBasePairs}
            showAbstractView={showAbstractView}
            transitionFactor={transitionFactor}
            zoom={zoom}
            fontSize={fontSize}
            bpPerPixel={bpPerPixel}
            totalWidth={totalWidth}
            lineX={lineX}
            lineY={lineY}
            bpToX={bpToX}
            hasDraggedRef={hasDraggedRef}
            dragComponentStartRef={dragComponentStartRef}
            selectionDragRef={selectionDragRef}
            onBaseMouseDown={handleBaseMouseDown}
            onCursorMove={handleCursorMove}
            onCursorLeave={handleCursorLeave}
            onBaseEnter={handleBaseEnter}
            onBaseLeave={handleBaseLeave}
            onComponentClick={handleComponentClick}
            onComponentMouseDown={handleComponentMouseDown}
            onComponentDelete={handleNodeDelete}
            getCursorPositionFromMouse={getCursorPositionFromMouse}
            setCursorPosition={setCursorPosition}
            setCursorVisible={setCursorVisible}
            dragGap={dragPreviewPosition ? { startBp: dragPreviewPosition.bp, length: dragPreviewPosition.componentLength } : null}
            highlightedPartIds={dragPreviewPosition?.blockedPartIds || []}
            onPartMouseDown={handlePartMouseDown}
            onPartDelete={handleDeletePlacedPart}
          />
          <DNACursor
            cursorVisible={cursorVisible}
            cursorPosition={cursorPosition}
            showBasePairs={showBasePairs}
            cursorPlaced={cursorPlaced}
            zoom={zoom}
            bpToX={bpToX}
            lineX={lineX}
            lineY={lineY}
          />
          <DNASelectionHighlight
            selection={selection}
            showBasePairs={showBasePairs}
            dnaLength={dnaLength}
            zoom={zoom}
            bpToX={bpToX}
            lineX={lineX}
            lineY={lineY}
          />
          {/* Drag preview box at DNA position - spans the gap, centered to match mouse-following box */}
          {dragPreviewPosition && showBasePairs && (() => {
            // Calculate gap positioning to match DNA renderer
            const gapStartBp = dragPreviewPosition.bp
            const gapLength = dragPreviewPosition.componentLength
            const gapStartX = bpToX(gapStartBp)
            const gapEndX = bpToX(gapStartBp + gapLength)
            const gapWidth = gapEndX - gapStartX
            
            // Center the box: position at center of gap, then use translateX(-50%) to center visually
            const gapCenterX = gapStartX + gapWidth / 2
            
            // Match dropped-box styling: solid body, only the two letter rows are translucent
            // Pixel-align to avoid seams
            // Match placed box sizing (minimum headroom for delete control / consistent feel)
            const overhangPx = Math.max(22, Math.round(baseHeight * 0.35))
            const baseHeightPx = Math.round(baseHeight)
            const strandSpacingPx = Math.round(strandSpacing)
            const boxHeightPx = strandSpacingPx + baseHeightPx + (overhangPx * 2)
            
            // Use component color (same as abstract view) instead of gray
            const componentColor = COMPONENT_COLORS[dragPreviewPosition.componentType] || '#95a5a6'
            // Helper to convert hex to rgba
            const hexToRgba = (hex: string, alpha: number) => {
              const r = parseInt(hex.slice(1, 3), 16)
              const g = parseInt(hex.slice(3, 5), 16)
              const b = parseInt(hex.slice(5, 7), 16)
              return `rgba(${r}, ${g}, ${b}, ${alpha})`
            }
            const solid = hexToRgba(componentColor, 1)
            const strip = hexToRgba(componentColor, 0.82)
            const topStripStartPx = overhangPx
            const topStripEndPx = overhangPx + baseHeightPx
            const bottomStripStartPx = overhangPx + strandSpacingPx
            const bottomStripEndPx = overhangPx + strandSpacingPx + baseHeightPx
            const bg = `linear-gradient(to bottom,
              ${solid} 0px,
              ${solid} ${topStripStartPx}px,
              ${strip} ${topStripStartPx}px,
              ${strip} ${topStripEndPx}px,
              ${solid} ${topStripEndPx}px,
              ${solid} ${bottomStripStartPx}px,
              ${strip} ${bottomStripStartPx}px,
              ${strip} ${bottomStripEndPx}px,
              ${solid} ${bottomStripEndPx}px,
              ${solid} ${boxHeightPx}px
            )`
            
            return (
              <div
                style={{
                  position: 'absolute',
                  left: `${lineX + gapCenterX}px`,
                  top: `${lineY - (strandSpacingPx + baseHeightPx) / 2 - overhangPx}px`,
                  width: `${gapWidth}px`,
                  height: `${boxHeightPx}px`,
                  background: bg,
                  border: `2px solid ${dragPreviewPosition.snappedFromBlocked ? '#e67e22' : '#6f6f6f'}`,
                  borderRadius: '2px',
                  boxSizing: 'border-box',
                  overflow: 'hidden',
                  pointerEvents: 'none',
                  zIndex: 1000,
                  transform: 'translateX(-50%)',
                  // No movement animation (user preference)
                  transition: 'none',
                }}
              >
                {/* Render NNN... while dragging so it doesn't look empty, and so you don't notice bases shifting behind */}
                <div
                  style={{
                    position: 'absolute',
                    left: 0,
                    top: `${topStripStartPx}px`,
                    height: `${baseHeightPx}px`,
                    width: '100%',
                    display: 'grid',
                    gridTemplateColumns: `repeat(${Math.max(1, gapLength)}, 1fr)`,
                    pointerEvents: 'none',
                    fontFamily: 'Courier New, monospace',
                    fontWeight: 700,
                    fontSize: `${fontSize}px`,
                    color: '#000',
                    lineHeight: `${baseHeightPx}px`,
                    textShadow: '0 1px 0 rgba(255,255,255,0.25)',
                  }}
                >
                  {Array.from({ length: Math.max(1, gapLength) }, (_, i) => (
                    <div key={`tp-prev-s-${i}`} style={{ textAlign: 'center', userSelect: 'none' }}>
                      N
                    </div>
                  ))}
                </div>
                <div
                  style={{
                    position: 'absolute',
                    left: 0,
                    top: `${bottomStripStartPx}px`,
                    height: `${baseHeightPx}px`,
                    width: '100%',
                    display: 'grid',
                    gridTemplateColumns: `repeat(${Math.max(1, gapLength)}, 1fr)`,
                    pointerEvents: 'none',
                    fontFamily: 'Courier New, monospace',
                    fontWeight: 700,
                    fontSize: `${fontSize}px`,
                    color: '#000',
                    lineHeight: `${baseHeightPx}px`,
                    opacity: 0.95,
                    textShadow: '0 1px 0 rgba(255,255,255,0.25)',
                  }}
                >
                  {Array.from({ length: Math.max(1, gapLength) }, (_, i) => (
                    <div key={`tp-prev-a-${i}`} style={{ textAlign: 'center', userSelect: 'none' }}>
                      N
                    </div>
                  ))}
                </div>
              </div>
            )
          })()}

          {/* Drag preview box in abstract view (snap to DNA coordinate even when bases hidden) */}
          {dragPreviewPosition && !showBasePairs && (() => {
            // Match the placed abstract block appearance (solid color, no letters, spans both strands)
            const startBp = dragPreviewPosition.bp
            const length = dragPreviewPosition.componentLength
            const startX = bpToX(startBp)
            const endX = bpToX(startBp + length)
            const width = endX - startX
            const centerX = startX + width / 2

            const abstractBoxHeight = strandSpacing + baseHeight
            const abstractBoxTop = lineY - strandSpacing / 2 - baseHeight / 2

            const componentColor = COMPONENT_COLORS[dragPreviewPosition.componentType] || '#95a5a6'
            const borderColor = dragPreviewPosition.snappedFromBlocked ? '#e67e22' : '#333'

            return (
              <div
                style={{
                  position: 'absolute',
                  left: `${lineX + centerX}px`,
                  top: `${abstractBoxTop}px`,
                  width: `${width}px`,
                  height: `${abstractBoxHeight}px`,
                  background: componentColor,
                  border: `1px solid ${borderColor}`,
                  borderRadius: '2px',
                  boxSizing: 'border-box',
                  overflow: 'hidden',
                  pointerEvents: 'none',
                  zIndex: 1000,
                  transform: 'translate(-50%, 0)',
                  transition: 'none',
                  boxShadow: '0 0 4px rgba(0,0,0,0.15)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: `${Math.max(8, Math.min(14, 8 * zoom))}px`,
                  color: '#fff',
                  fontFamily: 'Courier New, monospace',
                  fontWeight: 600,
                  opacity: 0.9,
                }}
              >
                {dragPreviewPosition.componentName}
              </div>
            )
          })()}
          {showAbstractView && scrollContainerRef.current && components
            .filter((comp) => comp.startBp === undefined) // Only render CircuitNode for components NOT placed on DNA
            .map((comp) => {
            const scrollLeft = scrollContainerRef.current?.scrollLeft || 0
            return (
              <div 
                key={comp.id} 
                style={{ 
                  pointerEvents: 'auto', 
                  position: 'absolute', 
                  left: `${comp.x}px`, 
                  top: `${comp.y}px`,
                  zIndex: 2,
                }}
              >
                <CircuitNode
                  component={{
                    ...comp,
                    x: comp.x - scrollLeft,
                  }}
                  isSelected={selectedId === comp.id}
                  onSelect={() => setSelectedId(comp.id)}
                  onMove={(id, x, y) => {
                    if (scrollContainerRef.current) {
                      const currentScrollLeft = scrollContainerRef.current.scrollLeft
                      handleNodeMove(id, x + currentScrollLeft, y)
                    }
                  }}
                  onDelete={handleNodeDelete}
                />
              </div>
            )
          })}
        </div>
      </div>
      <CustomScrollbar
        scrollLeft={scrollLeft}
        isDraggingHScroll={scrollbar.isDraggingHScroll}
        hasHorizontalScroll={scrollbar.hasHorizontalScroll}
        hScrollTrackWidth={scrollbar.hScrollTrackWidth}
        hScrollThumbWidth={scrollbar.hScrollThumbWidth}
        hScrollThumbLeft={scrollbar.hScrollThumbLeft}
        scrollbarSize={scrollbar.scrollbarSize}
        hScrollTrackRef={scrollbar.hScrollTrackRef}
        onMouseDown={scrollbar.handleHScrollMouseDown}
      />
      {/* Top-right controls: zoom info + zoom buttons */}
      <div className="top-right-controls">
        <div className="zoom-info">
          <span className="zoom-level">{zoom.toFixed(1)}x</span>
          <span className="view-mode">{showBasePairs ? 'DNA View' : 'Parts View'}</span>
        </div>
        <div className="zoom-buttons">
          <button
            className="zoom-btn"
            onClick={() => setZoom(Math.min(10, zoom * 1.1))}
            title="Zoom In"
          >
            +
          </button>
          <button
            className="zoom-btn"
            onClick={() => setZoom(Math.max(0.5, zoom / 1.1))}
            title="Zoom Out"
          >
            
          </button>
        </div>
      </div>
      {selection && (
        <SelectionInfo
          selection={selection}
          dnaSequence={dnaSequence}
        />
      )}
      <ContextMenu
        contextMenu={contextMenu}
        selection={selection}
        clipboard={clipboard}
        cursorPosition={cursorPosition}
        dnaSequence={dnaSequence}
        isInsideComponent={contextMenu ? isInsideComponent(contextMenu.bp) : false}
        onClose={() => setContextMenu(null)}
        onCopy={handleCopySelection}
        onCut={handleCutSelection}
        onPaste={handlePaste}
        onReverseComplement={handleReverseComplement}
        onDelete={handleDeleteSelection}
        onSetOrigin={handleSetOrigin}
      />
      <DragPreview
        bpPerPixel={bpPerPixel}
        strandSpacing={strandSpacing}
        baseHeight={baseHeight}
        dragPreviewPosition={dragPreviewPosition}
      />
      {/* Bottom status bar */}
      <div className="canvas-status-bar">
        <span className="status-filename">{fileName}</span>
        <span className="status-separator">|</span>
        <span className="status-info">{dnaLength} bp</span>
        {selection && (
          <>
            <span className="status-separator">|</span>
            <span className="status-info">Selected: {selection.startBp}-{selection.endBp}</span>
          </>
        )}
      </div>
    </div>
  )
}
